{"version":3,"file":"training.worker-BDP5YVMN.js","sources":["../src/workers/training.worker.ts"],"sourcesContent":["/**\n * Training Web Worker\n * Handles heavy computations off the main thread.\n * Note: TensorFlow.js must run on main thread, but we can offload\n * data processing and coordinate training batches.\n */\n\nexport interface WorkerMessage {\n  type: 'process_batch' | 'calculate_metrics' | 'generate_grid';\n  payload: unknown;\n}\n\nexport interface WorkerResponse {\n  type: 'batch_ready' | 'metrics_ready' | 'grid_ready' | 'error';\n  payload: unknown;\n}\n\n// Handle messages from main thread\nself.onmessage = (event: MessageEvent<WorkerMessage>) => {\n  const { type, payload } = event.data;\n\n  try {\n    switch (type) {\n      case 'process_batch':\n        handleProcessBatch(payload as BatchPayload);\n        break;\n      case 'calculate_metrics':\n        handleCalculateMetrics(payload as MetricsPayload);\n        break;\n      case 'generate_grid':\n        handleGenerateGrid(payload as GridPayload);\n        break;\n      default:\n        throw new Error(`Unknown message type: ${type}`);\n    }\n  } catch (error) {\n    self.postMessage({\n      type: 'error',\n      payload: { message: error instanceof Error ? error.message : 'Unknown error' },\n    } as WorkerResponse);\n  }\n};\n\ninterface BatchPayload {\n  data: Array<{ x: number; y: number; label: number }>;\n  batchSize: number;\n}\n\ninterface MetricsPayload {\n  predictions: number[];\n  labels: number[];\n  numClasses: number;\n}\n\ninterface GridPayload {\n  gridSize: number;\n  xRange: [number, number];\n  yRange: [number, number];\n}\n\n/**\n * Shuffles and batches data for training.\n */\nfunction handleProcessBatch(payload: BatchPayload): void {\n  const { data, batchSize } = payload;\n  \n  // Shuffle data\n  const shuffled = [...data];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j]!, shuffled[i]!];\n  }\n\n  // Create batch\n  const batch = batchSize > 0 && batchSize < shuffled.length\n    ? shuffled.slice(0, batchSize)\n    : shuffled;\n\n  self.postMessage({\n    type: 'batch_ready',\n    payload: { batch },\n  } as WorkerResponse);\n}\n\n/**\n * Calculates confusion matrix and metrics.\n */\nfunction handleCalculateMetrics(payload: MetricsPayload): void {\n  const { predictions, labels, numClasses } = payload;\n  \n  // Build confusion matrix\n  const matrix: number[][] = Array(numClasses)\n    .fill(null)\n    .map(() => Array(numClasses).fill(0) as number[]);\n\n  for (let i = 0; i < predictions.length; i++) {\n    const actual = labels[i] ?? 0;\n    const predicted = predictions[i] ?? 0;\n    if (matrix[actual]) {\n      matrix[actual][predicted] = (matrix[actual][predicted] ?? 0) + 1;\n    }\n  }\n\n  // Calculate per-class metrics\n  const classMetrics: Array<{ precision: number; recall: number; f1: number }> = [];\n  \n  for (let c = 0; c < numClasses; c++) {\n    let tp = 0, fp = 0, fn = 0;\n    \n    for (let i = 0; i < numClasses; i++) {\n      for (let j = 0; j < numClasses; j++) {\n        const count = matrix[i]?.[j] ?? 0;\n        if (i === c && j === c) tp += count;\n        else if (j === c) fp += count;\n        else if (i === c) fn += count;\n      }\n    }\n\n    const precision = tp + fp > 0 ? tp / (tp + fp) : 0;\n    const recall = tp + fn > 0 ? tp / (tp + fn) : 0;\n    const f1 = precision + recall > 0 ? 2 * precision * recall / (precision + recall) : 0;\n    \n    classMetrics.push({ precision, recall, f1 });\n  }\n\n  // Macro averages\n  const macroPrecision = classMetrics.reduce((sum, m) => sum + m.precision, 0) / numClasses;\n  const macroRecall = classMetrics.reduce((sum, m) => sum + m.recall, 0) / numClasses;\n  const macroF1 = classMetrics.reduce((sum, m) => sum + m.f1, 0) / numClasses;\n\n  self.postMessage({\n    type: 'metrics_ready',\n    payload: {\n      matrix,\n      classMetrics,\n      macro: { precision: macroPrecision, recall: macroRecall, f1: macroF1 },\n    },\n  } as WorkerResponse);\n}\n\n/**\n * Generates prediction grid points.\n */\nfunction handleGenerateGrid(payload: GridPayload): void {\n  const { gridSize, xRange, yRange } = payload;\n  \n  const grid: Array<{ x: number; y: number }> = [];\n  const xStep = (xRange[1] - xRange[0]) / (gridSize - 1);\n  const yStep = (yRange[1] - yRange[0]) / (gridSize - 1);\n\n  for (let i = 0; i < gridSize; i++) {\n    for (let j = 0; j < gridSize; j++) {\n      grid.push({\n        x: xRange[0] + j * xStep,\n        y: yRange[0] + i * yStep,\n      });\n    }\n  }\n\n  self.postMessage({\n    type: 'grid_ready',\n    payload: { grid },\n  } as WorkerResponse);\n}\n\nexport {};\n"],"names":["event","type","payload","handleProcessBatch","handleCalculateMetrics","handleGenerateGrid","error","data","batchSize","shuffled","i","j","batch","predictions","labels","numClasses","matrix","actual","predicted","classMetrics","c","tp","fp","fn","count","precision","recall","f1","macroPrecision","sum","m","macroRecall","macroF1","gridSize","xRange","yRange","grid","xStep","yStep"],"mappings":"yBAkBA,KAAK,UAAaA,GAAuC,CACvD,KAAM,CAAE,KAAAC,EAAM,QAAAC,CAAA,EAAYF,EAAM,KAEhC,GAAI,CACF,OAAQC,EAAA,CACN,IAAK,gBACHE,EAAmBD,CAAuB,EAC1C,MACF,IAAK,oBACHE,EAAuBF,CAAyB,EAChD,MACF,IAAK,gBACHG,EAAmBH,CAAsB,EACzC,MACF,QACE,MAAM,IAAI,MAAM,yBAAyBD,CAAI,EAAE,CAAA,CAErD,OAASK,EAAO,CACd,KAAK,YAAY,CACf,KAAM,QACN,QAAS,CAAE,QAASA,aAAiB,MAAQA,EAAM,QAAU,eAAA,CAAgB,CAC5D,CACrB,CACF,EAsBA,SAASH,EAAmBD,EAA6B,CACvD,KAAM,CAAE,KAAAK,EAAM,UAAAC,CAAA,EAAcN,EAGtBO,EAAW,CAAC,GAAGF,CAAI,EACzB,QAASG,EAAID,EAAS,OAAS,EAAGC,EAAI,EAAGA,IAAK,CAC5C,MAAMC,EAAI,KAAK,MAAM,KAAK,UAAYD,EAAI,EAAE,EAC5C,CAACD,EAASC,CAAC,EAAGD,EAASE,CAAC,CAAC,EAAI,CAACF,EAASE,CAAC,EAAIF,EAASC,CAAC,CAAE,CAC1D,CAGA,MAAME,EAAQJ,EAAY,GAAKA,EAAYC,EAAS,OAChDA,EAAS,MAAM,EAAGD,CAAS,EAC3BC,EAEJ,KAAK,YAAY,CACf,KAAM,cACN,QAAS,CAAE,MAAAG,CAAA,CAAM,CACA,CACrB,CAKA,SAASR,EAAuBF,EAA+B,CAC7D,KAAM,CAAE,YAAAW,EAAa,OAAAC,EAAQ,WAAAC,CAAA,EAAeb,EAGtCc,EAAqB,MAAMD,CAAU,EACxC,KAAK,IAAI,EACT,IAAI,IAAM,MAAMA,CAAU,EAAE,KAAK,CAAC,CAAa,EAElD,QAASL,EAAI,EAAGA,EAAIG,EAAY,OAAQH,IAAK,CAC3C,MAAMO,EAASH,EAAOJ,CAAC,GAAK,EACtBQ,EAAYL,EAAYH,CAAC,GAAK,EAChCM,EAAOC,CAAM,IACfD,EAAOC,CAAM,EAAEC,CAAS,GAAKF,EAAOC,CAAM,EAAEC,CAAS,GAAK,GAAK,EAEnE,CAGA,MAAMC,EAAyE,CAAA,EAE/E,QAASC,EAAI,EAAGA,EAAIL,EAAYK,IAAK,CACnC,IAAIC,EAAK,EAAGC,EAAK,EAAGC,EAAK,EAEzB,QAASb,EAAI,EAAGA,EAAIK,EAAYL,IAC9B,QAASC,EAAI,EAAGA,EAAII,EAAYJ,IAAK,CACnC,MAAMa,EAAQR,EAAON,CAAC,IAAIC,CAAC,GAAK,EAC5BD,IAAMU,GAAKT,IAAMS,EAAGC,GAAMG,EACrBb,IAAMS,EAAGE,GAAME,EACfd,IAAMU,IAAGG,GAAMC,EAC1B,CAGF,MAAMC,EAAYJ,EAAKC,EAAK,EAAID,GAAMA,EAAKC,GAAM,EAC3CI,EAASL,EAAKE,EAAK,EAAIF,GAAMA,EAAKE,GAAM,EACxCI,EAAKF,EAAYC,EAAS,EAAI,EAAID,EAAYC,GAAUD,EAAYC,GAAU,EAEpFP,EAAa,KAAK,CAAE,UAAAM,EAAW,OAAAC,EAAQ,GAAAC,EAAI,CAC7C,CAGA,MAAMC,EAAiBT,EAAa,OAAO,CAACU,EAAKC,IAAMD,EAAMC,EAAE,UAAW,CAAC,EAAIf,EACzEgB,EAAcZ,EAAa,OAAO,CAACU,EAAKC,IAAMD,EAAMC,EAAE,OAAQ,CAAC,EAAIf,EACnEiB,EAAUb,EAAa,OAAO,CAACU,EAAKC,IAAMD,EAAMC,EAAE,GAAI,CAAC,EAAIf,EAEjE,KAAK,YAAY,CACf,KAAM,gBACN,QAAS,CACP,OAAAC,EACA,aAAAG,EACA,MAAO,CAAE,UAAWS,EAAgB,OAAQG,EAAa,GAAIC,CAAA,CAAQ,CACvE,CACiB,CACrB,CAKA,SAAS3B,EAAmBH,EAA4B,CACtD,KAAM,CAAE,SAAA+B,EAAU,OAAAC,EAAQ,OAAAC,CAAA,EAAWjC,EAE/BkC,EAAwC,CAAA,EACxCC,GAASH,EAAO,CAAC,EAAIA,EAAO,CAAC,IAAMD,EAAW,GAC9CK,GAASH,EAAO,CAAC,EAAIA,EAAO,CAAC,IAAMF,EAAW,GAEpD,QAASvB,EAAI,EAAGA,EAAIuB,EAAUvB,IAC5B,QAASC,EAAI,EAAGA,EAAIsB,EAAUtB,IAC5ByB,EAAK,KAAK,CACR,EAAGF,EAAO,CAAC,EAAIvB,EAAI0B,EACnB,EAAGF,EAAO,CAAC,EAAIzB,EAAI4B,CAAA,CACpB,EAIL,KAAK,YAAY,CACf,KAAM,aACN,QAAS,CAAE,KAAAF,CAAA,CAAK,CACC,CACrB"}